\section{Conclusion}
Virtually all software in use today has bugs, many of which lie dormant until conditions line up perfectly for those bugs to manifest themselves. This is case for 2to3, which translates some rarely used code structures inaccurately. With formal verification, the translation of print statements was made mathematically verifiably conformant to a specification of how they should be translated, resulting in a more accurate translator that performed better. However, perfect accuracy comes at the cost of harder maintainability of translated code, showing that formal verification is not a silver bullet for all software bugs. Despite that, formal verification has shown itself useful in identifying and correcting hidden bugs, and greater use of formal verification is likely to uncover even more bugs in all sorts of software. Formal verification has seen ever wider use in software development, and this project has shown that formal verification can bring benefits even outside of safety-critical applications. Code translators of all sorts, from compilers to transpilers, can all benefit from formal verification, especially when translations involve many minute details that all need to be correct. Code translators are perfect candidates for expanded use of formal verification, yet they are only one type of many software which can benefit from formal verification.

\subsection{Limitations}

\subsubsection{Validity}
The validity of fix-print rests on the validity of Coq and its code extraction capabilities. Should Coq or its code extraction capabilities prove flawed, the validility of fix-print would also be flawed. However, given Coq's extensive history and use in both mathematics and computer science, such an outcome is unlikely.

\subsubsection{Scope}
Due to time limitations, fix-print only covered part of what 2to3 currently does. fix-print only covers 1 out of 2to3's 52 fixers, and so there is much that needs to be added to make fix-print a truly viable alternative to 2to3. In addition, the parsing stage of fix-print, where the unstructured text of code is turned into structured data for the translator to actually translate, was not formally verified, so fix-print is not yet completely formally verified from end to end. However, this is common in formal verification projects, where the most important logic of a program is formally verified first and peripheral items are verified later.

\subsubsection{Tests}
fix-print was only tested for computational accuracy against 2to3's test suite, which only includes 16 tests. Although the tests try to model the most common print statement structures found in real code, with such a small number of tests there is likely to be some sort of uncommon structure that is missed in the tests. Since fix-print was not tested on any actual codebases in current use, research on fix-print's effectivess in real codebases should be done to further test its real-world accuracy and performance.

\subsection{Future Research}
\subsubsection{Other Verification Languages}
Formal verification using the Coq proof assistant was chosen as the method of formal verification for this project due its use in previous research into formally verified code translators \autocite{Leroy}\autocite{Zhao}. As a theorem prover, Coq is based in math as much as it is based in programming, and Coq is frequently used to proven pure mathematical theorems as well as theorems about the correctness of software programs. However, there are other methods of formal verification possible. One example is the Java Modeling Language (JML), an addition to the popular Java programming language that allows Java developers to define specifications for their existing Java code in Java itself \autocite{Burdy}. This is a simpler approach to formal verification for Java developers, since it allows them to write both their code and their specifications in one language, especially important for those working on large Java codebases where switching programming languages for formal verification is infeasible. Another possible approach is Dafny, a programming language designed for formal verification. Dafny is structurally much more similar to traditional programming languages than Coq is, but allows for specification of what code should do. Both JML and Dafny are more accessible than Coq for most programmers, thus building formally verified code translators with such tooling may be more feasible than building one with Coq, thus making it a possible area of future research.

\subsubsection{Translating Different Languages}
Another area of possible future research is in the formal verification of translators between two vastly different programming languages. The need for CompCert (the formally verified C compiler) arose from the fact that C code and machine code are extremely different and machine code is largely not readable for humans, meaning it is difficult for a person to verify that all code was translated perfectly according to specification, thus requiring the help of formal verification to ensure translations are perfectly conformant to specifications. While Python 2 and 3 have quite a few differences, at the end of the day they are still extremely similar and human verification that translations from Python 2 to 3 are correct is very feasible. Translating between programming languages with significant differences is harder to hand-verify, and thus is a promising area for for future research into formally verified code translators.