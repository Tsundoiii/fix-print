\section{Literature Review}

\subsection{Python 2 vs. 3}
\begin{table*}[b!]
    \begin{tabular}{@{}l|l@{}}
    \toprule
    Python 2             & Python 3              \\ \midrule
    \lstinline[language=Python, style=pythonstyle]|print "Hello World"|  & \lstinline[language=Python, style=pythonstyle]|print("Hello World")|  \\
    \lstinline[language=Python, style=pythonstyle]|exec "print (1 + 1)"| & \lstinline[language=Python, style=pythonstyle]|exec("print (1 + 1)")| \\
    \lstinline[language=Python, style=pythonstyle]|u"Hello World"|       & \lstinline[language=Python, style=pythonstyle]|"Hello World"|\\  \bottomrule      
    \end{tabular}
    \caption{A few examples of changes from Python 2 to 3, from differences in the syntax of statements for printing out text to an output and executing Python code within a Python program, to differences in how text itself is stored differently between both versions.}
    \label{tab:python-2-vs-3}
\end{table*}

The core of the Python language is a program known as the interpreter, which reads Python source code from a text file or other input source and executes the code as it reads it. A 'version' of the Python language is simply a version of the interpreter, and each new version of the interpreter includes updates that allow the interpreter to read new code syntaxes, as well as other upgrades such as performance boosts. Usually, each new interpreter version is \textit{backwards compatible}, meaning code that executed without issue in the previous version also executes without issue and with the same behavior on the new version \autocite{Malloy}. Backwards compatibility is highly valued due to the high usage of the language, and the PSF usually attempts to maintain backwards compatibility as much as reasonably possible.

However, in December 2008, Python version 3.0 was released. According to the PSF, Python 3.0 was the first ever “intentionally backwards incompatible” release of Python \autocite{vanRossum}. Python 3.0 included numerous syntax changes that meant that the Python 3.0 interpreter was unable to run most code written in Python 2, since it could not recognize the old syntax. According to Guido van Rossum, the creator of Python and head of its development at the time, the purpose of such wide-reaching changes was, “fixing well-known annoyances and warts, and removing a lot of old cruft” \autocite{vanRossum}.

To assist in the massive task of converting entire codebases from Python 2 to Python 3, a program known as 2to3 was created by the PSF \autocite{2to3}. 2to3 is a \textit{transpiler} --- a program that translates one programming language to another --- that converts Python 2 code to Python 3 code. However, 2to3 did not prove as popular as hoped, and the prevailing conversion strategy eventually became to use tools to delicately make a single codebase that could run under Python 2 and Python 3 \autocite{Malloy}. The overall transition from Python 2 to Python 3 has also been rocky, as many Python developers even a decade after the transition began are still attempting to maintain the balance between Python 2 and 3 \autocite{Malloy}. However, all versions of Python 2 have lost support from the PSF, meaning they will not receive any feature updates, or, more critically, any security updates, and all focus is now on maintaining Python 3. Thus, the importance of converting the remaining Python 2 codebases is great.

\subsection{Code Translation}
The problem of code translation has been approached in a number of different ways. One way has been to use techniques from the field of natural language machine translation. One 2014 study used the technique of statistical machine translation --- translating language based on the probability that a given translation is a correct translation of the original language --- to translate from the C\# programming language to the Java programming language \autocite{Karaivanov}. According to them, 68\% of the code produced by the translator was 'semantically equivalent,' meaning that the translated code was essentially the same as the original code.

Python 2 to 3 translation specifically has not been a widely researched topic within the field of code translation research. However, the one study that has been done on the topic also used the technique of statistical machine translation to translate from Python 2 to Python 3. Researchers from the University of Alberta created the translator and evaluated its effectiveness using a metric called BLEU, which is a metric used by natural language machine translation researchers that is based on the premise that if a given translation is highly similar to known 'correct' translations, then the translation is likely to be correct \autocite{Aggarwal}.

However, a 2020 research paper from Facebook Research (now Meta Research) that used neural machine translation --- the use of neural networks to translate languages --- to translate between various programming languages, criticized the use of BLEU as a metric for evaluating the effectiveness of code translators, given that a translation that is missing a 'word' or even a single character may still be highly similar to a correct translation, but still give the wrong result or fail to run at all due to the need for code to be highly precise in a much more extreme way than natural languages do \autocite{Roziere}. They measured effectiveness by creating their own metric known as computational accuracy, in which a translation that gives the same output when executed as the original code does is deemed successful. Their translator had widely varying success rates depending on the source and target language used. The most successful pairing source and target languages was Java to C++, and the least successful one was Python to Java \autocite{Roziere}.

\subsection{Formal Verification}
Since software of more than trivial complexity started being written, there has been a need for software to be verified to be free of bugs. One of the first models proposed for such verification was Hoare logic, first proposed in 1969 by the British mathematician C.A.R. Hoare. The basic statement in Hoare logic is the Hoare triple, which consists of a command and a precondition and postcondition. If the precondition is met before a command is run, then the command is run, and afterwards the postcondition is met, then the command is considered 'correct' when run with the specified conditions \autocite{Hoare}. Hoare logic has been highly influential, and has spawned the field of formal verification.

Although formal verification is most common in safety-critical industries such as transportation and other industries where verification of software is critical, formal verification has also been applied in other fields, such as compilers. A \textit{compiler} is a type of code translator that translates a programming language into machine code --- code that a computer recognizes and can run. Researchers from Inria, a French government-supported computer science research institute, created CompCert, a formally verified compiler for the C programming language \autocite{Leroy}. Compiling programming languages to machine code is a complex task that can result in notoriously difficult to catch bugs that only occur in certain conditions, so the goal of the CompCert project is to verify that all code is compiled correctly with no bugs. CompCert was able to achieve similar performance to mainstream C compilers despite needing more computations than a normal compiler would need due to the need to verify the correctness of compilations, showing that formally verified compilers are feasible to implement.

The next stage after research into formally verified compilers is research into formally verified transpilers, of which research is currently scant. A Python 2 to Python 3 transpiler was chosen as the research target due to the overall similarity of both versions, despite their large differences, making implementation easier. Such research will hopefully lead to even more research into the application of formally verified transpilers and of formally verified software in general, and hopefully ultimately result in the greater proliferation of formally verified software that can be verified to be free of bugs.