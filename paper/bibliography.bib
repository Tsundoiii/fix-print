@manual{2to3,
  author = {Python Software Foundation},
  title  = {2to3 — Automated Python 2 to 3 code translation},
  url    = {https://docs.python.org/3/library/2to3.html}
}

@article{Aggarwal,
  author = {Aggarwal, Karan and Salameh, Mohammad and Hindle, Abram},
  year   = {2015},
  month  = {10},
  pages  = {},
  title  = {Using machine translation for converting Python 2 to Python 3 code},
  doi    = {10.7287/PEERJ.PREPRINTS.1459V1}
}

@inproceedings{Blazy,
  author    = {Blazy, Sandrine and Dargaye, Zaynah and Leroy, Xavier},
  title     = {Formal Verification of a c Compiler Front-End},
  year      = {2006},
  isbn      = {3540372156},
  publisher = {Springer-Verlag},
  address   = {Berlin, Heidelberg},
  url       = {https://doi.org/10.1007/11813040_31},
  doi       = {10.1007/11813040_31},
  abstract  = {This paper presents the formal verification of a compiler front-end that translates a subset of the C language into the Cminor intermediate language. The semantics of the source and target languages as well as the translation between them have been written in the specification language of the Coq proof assistant. The proof of observational semantic equivalence between the source and generated code has been machine-checked using Coq. An executable compiler was obtained by automatic extraction of executable Caml code from the Coq specification of the translator, combined with a certified compiler back-end generating PowerPC assembly code from Cminor, described in previous work.},
  booktitle = {Proceedings of the 14th International Conference on Formal Methods},
  pages     = {460–475},
  numpages  = {16},
  location  = {Hamilton, Canada},
  series    = {FM'06}
}

@article{Burdy,
  author   = {Burdy, Lilian and Cheon, Yoonsik and Cok, David R. and Ernst, Michael D. and Kiniry, Joseph R. and Leavens, Gary T. and Leino, Rustan and Poll, Erik},
  title    = {An Overview of JML Tools and Applications},
  year     = {2005},
  month    = {June},
  abstract = {The Java Modeling Language (JML) can be used to specify the detailed design of Java classes and interfaces by adding annotations to Java source files. The aim of JML is to provide a specification language that is easy to use for Java programmers and that is supported by a wide range of tools for specification type-checking, runtime debugging, static analysis, and verification.
              
              This paper gives an overview of the main ideas behind JML, the different groups collaborating to provide tools for JML, and the existing applications of JML. Thus far, most applications have focused on code for programming smartcards written in the Java Card dialect of Java.},
  url      = {https://www.microsoft.com/en-us/research/publication/overview-jml-tools-applications/},
  pages    = {212-232},
  journal  = {International Journal on Software Tools for Technology Transfer},
  volume   = {7},
  edition  = {International Journal on Software Tools for Technology Transfer},
  number   = {3}
}

@manual{Filliâtre,
  author = {Filliâtre, Jean-Christophe and Letouzey, Pierre},
  title  = {Program extraction},
  url    = {https://coq.inria.fr/doc/v8.13/refman/addendum/extraction.html}
}

@article{Hoare,
  author     = {Hoare, C. A. R.},
  title      = {An Axiomatic Basis for Computer Programming},
  year       = {1969},
  issue_date = {Oct. 1969},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {12},
  number     = {10},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/363235.363259},
  doi        = {10.1145/363235.363259},
  abstract   = {In this paper an attempt is made to explore the logical foundations of computer programming by use of techniques which were first applied in the study of geometry and have later been extended to other branches of mathematics. This involves the elucidation of sets of axioms and rules of inference which can be used in proofs of the properties of computer programs. Examples are given of such axioms and rules, and a formal proof of a simple theorem is displayed. Finally, it is argued that important advantage, both theoretical and practical, may follow from a pursuance of these topics.},
  journal    = {Commun. ACM},
  month      = {oct},
  pages      = {576–580},
  numpages   = {5},
  keywords   = {theory of programming' proofs of programs, programming language design, machine-independent programming, program documentation, formal language definition, axiomatic method}
}

@inproceedings{Karaivanov,
  author    = {Karaivanov, Svetoslav and Raychev, Veselin and Vechev, Martin},
  title     = {Phrase-Based Statistical Translation of Programming Languages},
  year      = {2014},
  isbn      = {9781450332101},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2661136.2661148},
  doi       = {10.1145/2661136.2661148},
  abstract  = {Phrase-based statistical machine translation approaches have been highly successful in translating between natural languages and are heavily used by commercial systems (e.g. Google Translate).The main objective of this work is to investigate the applicability of these approaches for translating between programming languages. Towards that, we investigated several variants of the phrase-based translation approach: i) a direct application of the approach to programming languages, ii) a novel modification of the approach to incorporate the grammatical structure of the target programming language (so to avoid generating target programs which do not parse), and iii) a combination of ii) with custom rules added to improve the quality of the translation.To experiment with the above systems, we investigated machine translation from C\# to Java. For the training, which takes about 60 hours, we used a parallel corpus of 20,499 C\#-to-Java method translations. We then evaluated each of the three systems above by translating 1,000 C\# methods. Our experimental results indicate that with the most advanced system, about 60\% of the translated methods compile (the top ranked) and out of a random sample of 50 correctly compiled methods, 68\% (34 methods) were semantically equivalent to the reference solution.},
  booktitle = {Proceedings of the 2014 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming \& Software},
  pages     = {173–184},
  numpages  = {12},
  keywords  = {statistical machine translation, programming language translation},
  location  = {Portland, Oregon, USA},
  series    = {Onward! 2014}
}

@article{Leroy,
  author     = {Leroy, Xavier},
  title      = {Formal Verification of a Realistic Compiler},
  year       = {2009},
  issue_date = {July 2009},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {52},
  number     = {7},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/1538788.1538814},
  doi        = {10.1145/1538788.1538814},
  abstract   = {This paper reports on the development and formal verification (proof of semantic preservation) of CompCert, a compiler from Clight (a large subset of the C programming language) to PowerPC assembly code, using the Coq proof assistant both for programming the compiler and for proving its correctness. Such a verified compiler is useful in the context of critical software and its formal verification: the verification of the compiler guarantees that the safety properties proved on the source code hold for the executable compiled code as well.},
  journal    = {Commun. ACM},
  month      = {jul},
  pages      = {107–115},
  numpages   = {9}
}

@inproceedings{Malloy,
  author    = {Malloy, Brian A. and Power, James F.},
  title     = {Quantifying the Transition from Python 2 to 3: An Empirical Study of Python Applications},
  year      = {2017},
  isbn      = {9781509040391},
  publisher = {IEEE Press},
  url       = {https://doi.org/10.1109/ESEM.2017.45},
  doi       = {10.1109/ESEM.2017.45},
  abstract  = {Background: Python is one of the most popular modern programming languages. In 2008 its authors introduced a new version of the language, Python 3.0, that was not backward compatible with Python 2, initiating a transitional phase for Python software developers. Aims: The study described in this paper investigates the degree to which Python software developers are making the transition from Python 2 to Python 3. Method: We have developed a Python compliance analyser, PyComply, and have assembled a large corpus of Python applications. We use PyComply to measure and quantify the degree to which Python 3 features are being used, as well as the rate and context of their adoption. Results: In fact, Python software developers are not exploiting the new features and advantages of Python 3, but rather are choosing to retain backward compatibility with Python 2. Conclusions: Python developers are confining themselves to a language subset, governed by the diminishing intersection of Python 2, which is not under development, and Python 3, which is under development with new features being introduced as the language continues to evolve.},
  booktitle = {Proceedings of the 11th ACM/IEEE International Symposium on Empirical Software Engineering and Measurement},
  pages     = {314–323},
  numpages  = {10},
  location  = {Markham, Ontario, Canada},
  series    = {ESEM '17}
}

@inproceedings{Roziere,
  author    = {Roziere, Baptiste and Lachaux, Marie-Anne and Chanussot, Lowik and Lample, Guillaume},
  title     = {Unsupervised Translation of Programming Languages},
  year      = {2020},
  isbn      = {9781713829546},
  publisher = {Curran Associates Inc.},
  address   = {Red Hook, NY, USA},
  abstract  = {A transcompiler, also known as source-to-source translator, is a system that converts source code from a high-level programming language (such as C++ or Python) to another. Transcompilers are primarily used for interoperability, and to port codebases written in an obsolete or deprecated language (e.g. COBOL, Python 2) to a modern one. They typically rely on handcrafted rewrite rules, applied to the source code abstract syntax tree. Unfortunately, the resulting translations often lack readability, fail to respect the target language conventions, and require manual modifications in order to work properly. The overall translation process is time-consuming and requires expertise in both the source and target languages, making code-translation projects expensive. Although neural models significantly outperform their rule-based counterparts in the context of natural language translation, their applications to transcompilation have been limited due to the scarcity of parallel data in this domain. In this paper, we propose to leverage recent approaches in unsupervised machine translation to train a fully unsupervised neural transcompiler. We train our model on source code from open source GitHub projects, and show that it can translate functions between C++, Java, and Python with high accuracy. Our method relies exclusively on monolingual source code, requires no expertise in the source or target languages, and can easily be generalized to other programming languages. We also build and release a test set composed of 852 parallel functions, along with unit tests to check the correctness of translations. We show that our model outperforms rule-based commercial baselines by a significant margin.},
  booktitle = {Proceedings of the 34th International Conference on Neural Information Processing Systems},
  articleno = {1730},
  numpages  = {11},
  location  = {Vancouver, BC, Canada},
  series    = {NIPS'20}
}

@online{vanRossum,
  author = {van Rossum, Guido},
  title  = {What's New In Python 3.0},
  url    = {https://docs.python.org/3/whatsnew/3.0.html}
}

@article{Wang,
  author     = {Wang, Bo and Kolluri, Aashish and Nikoli\'{c}, Ivica and Baluta, Teodora and Saxena, Prateek},
  title      = {User-Customizable Transpilation of Scripting Languages},
  year       = {2023},
  issue_date = {April 2023},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {7},
  number     = {OOPSLA1},
  url        = {https://doi.org/10.1145/3586034},
  doi        = {10.1145/3586034},
  abstract   = {A transpiler converts code from one programming language to another. Many practical uses of transpilers require the user to be able to guide or customize the program produced from a given input program. This customizability is important for satisfying many application-specific goals for the produced code such as ensuring performance, readability, ease of exposition or maintainability, compatibility with external environment or analysis tools, and so on. Conventional transpilers are deterministic rule-driven systems often written without offering customizability per user and per program. Recent advances in transpilers based on neural networks offer some customizability to users, e.g. through interactive prompts, but they are still difficult to precisely control the production of a desired output. Both conventional and neural transpilation also suffer from the "last mile" problem: they produce correct code on average, i.e., on most parts of a given program, but not necessarily for all parts of it. We propose a new transpilation approach that offers fine-grained customizability and reusability of transpilation rules created by others, without burdening the user to understand the global semantics of the given source program. Our approach is mostly automatic and incremental, i.e., constructs translation rules needed to transpile the given program as per the user's guidance piece-by-piece. Users can rely on existing transpilation rules to translate most of the program correctly while focusing their effort locally, only on parts that are incorrect or need customization. This improves the correctness of the end result. We implement the transpiler as a tool called DuoGlot, which translates Python to Javascript programs, and evaluate it on the popular GeeksForGeeks benchmarks. DuoGlot achieves 90\% translation accuracy and so it outperforms all existing translators (both handcrafted and neural-based), while it produces readable code. We evaluate DuoGlot on two additional benchmarks, containing more challenging and longer programs, and similarly observe improved accuracy compared to the other transpilers.},
  journal    = {Proc. ACM Program. Lang.},
  month      = {apr},
  articleno  = {82},
  numpages   = {29},
  keywords   = {Program Translation, Program Synthesis}
}

@article{Woodcock,
  author     = {Woodcock, Jim and Larsen, Peter Gorm and Bicarregui, Juan and Fitzgerald, John},
  title      = {Formal Methods: Practice and Experience},
  year       = {2009},
  issue_date = {October 2009},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {41},
  number     = {4},
  issn       = {0360-0300},
  url        = {https://doi.org/10.1145/1592434.1592436},
  doi        = {10.1145/1592434.1592436},
  abstract   = {Formal methods use mathematical models for analysis and verification at any part of the program life-cycle. We describe the state of the art in the industrial use of formal methods, concentrating on their increasing use at the earlier stages of specification and design. We do this by reporting on a new survey of industrial use, comparing the situation in 2009 with the most significant surveys carried out over the last 20 years. We describe some of the highlights of our survey by presenting a series of industrial projects, and we draw some observations from these surveys and records of experience. Based on this, we discuss the issues surrounding the industrial adoption of formal methods. Finally, we look to the future and describe the development of a Verified Software Repository, part of the worldwide Verified Software Initiative. We introduce the initial projects being used to populate the repository, and describe the challenges they address.},
  journal    = {ACM Comput. Surv.},
  month      = {oct},
  articleno  = {19},
  numpages   = {36},
  keywords   = {grand challenges, formal methods surveys, Experimental software engineering, verified software repository, verified software initiative}
}

@article{Zhao,
  author     = {Zhao, Jianzhou and Nagarakatte, Santosh and Martin, Milo M.K. and Zdancewic, Steve},
  title      = {Formalizing the LLVM Intermediate Representation for Verified Program Transformations},
  year       = {2012},
  issue_date = {January 2012},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {47},
  number     = {1},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/2103621.2103709},
  doi        = {10.1145/2103621.2103709},
  abstract   = {This paper presents Vellvm (verified LLVM), a framework for reasoning about programs expressed in LLVM's intermediate representation and transformations that operate on it. Vellvm provides a mechanized formal semantics of LLVM's intermediate representation, its type system, and properties of its SSA form. The framework is built using the Coq interactive theorem prover. It includes multiple operational semantics and proves relations among them to facilitate different reasoning styles and proof techniques.To validate Vellvm's design, we extract an interpreter from the Coq formal semantics that can execute programs from LLVM test suite and thus be compared against LLVM reference implementations. To demonstrate Vellvm's practicality, we formalize and verify a previously proposed transformation that hardens C programs against spatial memory safety violations. Vellvm's tools allow us to extract a new, verified implementation of the transformation pass that plugs into the real LLVM infrastructure; its performance is competitive with the non-verified, ad-hoc original.},
  journal    = {SIGPLAN Not.},
  month      = {jan},
  pages      = {427–440},
  numpages   = {14},
  keywords   = {memory safety, LLVM, Coq}
}